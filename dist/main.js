/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst STATUS_TIMEOUT = 1500;\nconst RETRYPLAY_TIMEOUT = 8000;\n\nconst LIVE_STATUS = \"Live\";\nconst OFFLINE_STATUS = \"Offline\";\nconst CONNECTING_STATUS = \"Connecting\";\n\nconst defaultOptions = {\n\tprogressUpdateTime: 750,\n\tconnectionRetries: Infinity,\n\terrorsBeforeStop: Infinity,\n};\n\nconst defaultConfig = {};\n\nwindow.vpMsePlayers = window.vpMsePlayers || new Map();\n\nconst vpMsePlayer = (elementId) => {\n\tconst players = window.vpMsePlayers;\n\tconst player = players.get(elementId);\n\n\tif (!elementId) {\n\t\treturn players.values().next().value;\n\t}\n\n\tif (player) {\n\t\treturn player;\n\t} else {\n\t\tconst player = new msePlayer(elementId);\n\t\tplayers.set(elementId, player);\n\t\treturn player;\n\t}\n};\n\nvpMsePlayer.destroy = (elementId) => {\n\tconst players = window.vpMsePlayers;\n\tconst player = players.get(elementId);\n\tif (player) {\n\t\tplayers.delete(elementId);\n\t}\n};\n\nclass msePlayer {\n\t/**\n\t * Create a new msePlayer instance.\n\t * @param {string} elementId - The ID of the HTML element to contain the player.\n\t */\n\tconstructor(elementId) {\n\t\tif (!elementId) {\n\t\t\tthrow new Error(\"ElementId is required\");\n\t\t}\n\n\t\tthis.elementId = elementId;\n\t\tthis.streamUrl = null;\n\t\tthis.options = null;\n\t\tthis.config = null;\n\t\tthis.player = null;\n\t}\n\n\tsetup(streamUrl, options, config) {\n\t\tif (!streamUrl) {\n\t\t\tthrow new Error(\"StreamUrl is required\");\n\t\t}\n\n\t\tthis.streamUrl = streamUrl;\n\t\tthis.options = options || defaultOptions;\n\t\tthis.config = config || defaultConfig;\n\t\tthis.init();\n\t}\n\n\t/**\n\t * Initialize the video player.\n\t * @private\n\t */\n\tasync init() {\n\t\tconst videoContainer = document.getElementById(this.elementId);\n\t\tif (!videoContainer) {\n\t\t\tthrow new Error(`Element with id \"${this.elementId}\" not found.`);\n\t\t}\n\t\tthis.videoContainer = videoContainer;\n\t\tthis.setupHTMLTemplate();\n\t\tawait this.initPlayer();\n\t\tthis.setInitialState();\n\t\tthis.addEventListeners();\n\t}\n\n\t/**\n\t * Initializes the MSE player instance.\n\t * If the library is already loaded, instantiates the player directly.\n\t * Otherwise, dynamically loads the library and instantiates it afterwards.\n\t *\n\t * @returns {Promise<void>}\n\t */\n\tasync initPlayer() {\n\t\ttry {\n\t\t\tif (window.msePlayer) {\n\t\t\t\tthis.player = new window.msePlayer(this.video, this.streamUrl, this.options);\n\t\t\t} else {\n\t\t\t\tawait this.loadMsePlayerLibrary();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Error initializing vpMsePlayer:\", error);\n\t\t\tthis.nonLiveStatus();\n\t\t}\n\t}\n\n\t/**\n\t * Dynamically loads the msePlayer library and initializes the player.\n\t * Only loads the script if not already available on the window object.\n\t *\n\t * @returns {Promise<void>} Resolves when the library is loaded and player is initialized.\n\t */\n\tloadMsePlayerLibrary() {\n\t\tif (window.msePlayer) return Promise.resolve();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst script = document.createElement(\"script\");\n\t\t\tscript.src = \"https://vpplayer-assets.eu-1.cdn77-storage.com/mse-player/msePlayer.js\";\n\n\t\t\tscript.onload = () => {\n\t\t\t\tif (window.msePlayer) {\n\t\t\t\t\tthis.player = new window.msePlayer(this.video, this.streamUrl, this.options);\n\t\t\t\t\tresolve();\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error(\"msePlayer loaded but not available on window\"));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tscript.onerror = () => {\n\t\t\t\treject(new Error(\"Failed to load msePlayer library\"));\n\t\t\t};\n\n\t\t\tdocument.head.appendChild(script);\n\t\t});\n\t}\n\n\t/**\n\t * Set the initial state of the video element.\n\t * @private\n\t */\n\tasync setInitialState() {\n\t\tthis.video.muted = true;\n\t\tthis.video.controls = this.config.controls || true;\n\t\tthis.playbackStarted = false;\n\t\tthis.nonLiveStatus();\n\t\tthis.play();\n\t}\n\n\t/**\n\t * Create the video element inside the container.\n\t * @private\n\t */\n\tsetupHTMLTemplate() {\n\t\tconst template = `\n\t\t<div class=\"vp-mse-channel-status\"></div>\n\t\t<video class=\"vp-mse-video\"></video>\n\t\t`;\n\t\tthis.videoContainer.classList.add(\"vp-mse-player-container\");\n\t\tthis.videoContainer.innerHTML = template;\n\t\tthis.video = this.videoContainer.querySelector(\"video\");\n\t\tthis.channelStatus = this.videoContainer.querySelector(\".vp-mse-channel-status\");\n\t\tthis.setSize();\n\t\tthis.setStyle();\n\t}\n\n\t/**\n\t * Apply size settings to the video container.\n\t * @private\n\t */\n\tsetSize() {\n\t\tif (this.config.size === undefined) {\n\t\t\tthis.videoContainer.style.width = \"100%\";\n\t\t\tthis.videoContainer.style.paddingTop = \"56.25%\";\n\t\t\treturn;\n\t\t}\n\n\t\tconst { width = \"100%\", height = \"100%\" } = this.config.size;\n\t\tthis.videoContainer.style.width = typeof width === \"number\" ? `${width}px` : width;\n\t\tthis.videoContainer.style.height = typeof height === \"number\" ? `${height}px` : height;\n\t}\n\n\t/**\n\t * Apply style settings to the player elements.\n\t * @private\n\t */\n\tsetStyle() {\n\t\tObject.assign(this.videoContainer.style, {\n\t\t\tposition: \"relative\",\n\t\t\toverflow: \"hidden\",\n\t\t\tbackgroundColor: \"#000\",\n\t\t\twidth: \"100%\",\n\t\t\theight: \"100%\",\n\t\t});\n\n\t\tObject.assign(this.video.style, {\n\t\t\tposition: \"absolute\",\n\t\t\twidth: \"100%\",\n\t\t\theight: \"100%\",\n\t\t\ttop: \"0\",\n\t\t\tleft: \"0\",\n\t\t\tborder: \"none\",\n\t\t});\n\n\t\tObject.assign(this.channelStatus.style, {\n\t\t\tposition: \"absolute\",\n\t\t\ttop: \"10px\",\n\t\t\tright: \"10px\",\n\t\t\tzIndex: \"9999\",\n\t\t\tpadding: \"3px 6px\",\n\t\t\tborderRadius: \"4px\",\n\t\t\tbackgroundColor: \"#ffffff8e\",\n\t\t\tfontFamily: \"Arial, sans-serif\",\n\t\t\tfontSize: \"12px\",\n\t\t\tfontWeight: \"bold\",\n\t\t});\n\t}\n\n\t/**\n\t * Add event listeners to the player.\n\t * @private\n\t */\n\taddEventListeners() {\n\t\tthis.player.onProgress = this.onProgress.bind(this);\n\t\tthis.video.onerror = this.onError.bind(this);\n\t\tthis.video.onwaiting = this.onWaiting.bind(this);\n\t\tthis.video.onprogress = this.onVideoProgress.bind(this);\n\t}\n\n\t/**\n\t * Handle progress event from the MSE player.\n\t * @private\n\t */\n\tonProgress(progress) {\n\t\tif (!this.playbackStarted) {\n\t\t\tthis.onStart();\n\t\t}\n\n\t\tthis.fire(\"progress\", progress);\n\n\t\tif (this.retryPlayTimeout) {\n\t\t\tthis.retryPlayTimeout = clearTimeout(this.retryPlayTimeout);\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\tonVideoProgress() {\n\t\tif (!this.playbackStarted) return;\n\n\t\t// Set status from non-live to live in case a progress event is received.\n\t\tif (this.status !== LIVE_STATUS) {\n\t\t\tthis.liveStatus();\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\tonStart() {\n\t\tthis.playbackStarted = true;\n\t}\n\n\t/**\n\t * @private\n\t */\n\tonWaiting() {\n\t\tif (this.statusTimeout) {\n\t\t\tthis.statusTimeout = clearTimeout(this.statusTimeout);\n\t\t}\n\n\t\t// If no progress event is received within the timeout, set status to offline.\n\t\tthis.statusTimeout = setTimeout(() => {\n\t\t\tthis.nonLiveStatus();\n\t\t}, STATUS_TIMEOUT);\n\t}\n\n\t/**\n\t * @private\n\t */\n\tonError(error) {\n\t\tconsole.warn(\"Video error:\", error);\n\t}\n\n\t/**\n\t * Set the player status to live.\n\t * @private\n\t */\n\tliveStatus() {\n\t\tconst status = LIVE_STATUS;\n\t\tif (this.status === status) return;\n\t\tthis.status = status;\n\t\tthis.channelStatus.innerHTML = status;\n\t\tthis.channelStatus.style.backgroundColor = \"#ffffff8e\";\n\t\tthis.channelStatus.style.color = \"#ff0000\";\n\t\tthis.fire(`channel${status}`, { message: `Channel is ${status}` });\n\t}\n\n\t/**\n\t * Set the player status to non-live.\n\t * @private\n\t */\n\tnonLiveStatus() {\n\t\tconst status = this.playbackStarted ? OFFLINE_STATUS : CONNECTING_STATUS;\n\t\tif (this.status === status) return;\n\t\tthis.status = status;\n\t\tthis.channelStatus.innerHTML = status;\n\t\tthis.channelStatus.style.backgroundColor = \"#0000008e\";\n\t\tthis.channelStatus.style.color = \"#ffffff\";\n\t\tthis.fire(`channel${status}`, { message: `Channel is ${status}` });\n\t}\n\n\t/**\n\t * Fire a custom event on an element.\n\t * @param {string} eventName - The name of the event.\n\t * @param {object} detail - The event detail object.\n\t * @param {object} options - Event options.\n\t * @private\n\t */\n\n\tfire(eventName, detail, options = {}) {\n\t\tconst event = new CustomEvent(eventName, {\n\t\t\tdetail: detail,\n\t\t\tbubbles: options.bubbles || true,\n\t\t\tcancelable: options.cancelable || true,\n\t\t});\n\t\tthis.videoContainer.dispatchEvent(event);\n\t}\n\n\t/**\n\t * Add an event listener to the player.\n\t * @param {string} eventName - The name of the event.\n\t * @param {function} callback - The event callback function.\n\t * @param {object} options - Event options.\n\t * @returns {void}\n\t */\n\ton(eventName, callback, options = {}) {\n\t\tthis.videoContainer.addEventListener(eventName, callback, options);\n\t\tthis.eventListeners = this.eventListeners || [];\n\t\tthis.eventListeners.push({ eventName, callback, options });\n\t}\n\n\t/**\n\t * Remove an event listener to the player.\n\t * @param {string} eventName - The name of the event.\n\t * @param {function} callback - The event callback function.\n\t * @returns {void}\n\t */\n\toff(eventName, callback) {\n\t\tthis.videoContainer.removeEventListener(eventName, callback);\n\t}\n\n\t/**\n\t * Remove all event listeners ever added to the player.\n\t * @returns {void}\n\t * @private\n\t */\n\tremoveEventListeners() {\n\t\tif (this.eventListeners) {\n\t\t\tthis.eventListeners.forEach(({ eventName, callback, options }) => {\n\t\t\t\tthis.videoContainer.removeEventListener(eventName, callback, options);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Clear any residual status timeouts.\n\t * @private\n\t */\n\tclearResiduals() {\n\t\tif (this.statusTimeout) this.statusTimeout = clearTimeout(this.statusTimeout);\n\t\tif (this.retryPlayTimeout) this.retryPlayTimeout = clearTimeout(this.retryPlayTimeout);\n\t}\n\n\t/**\n\t * Start video playback.\n\t */\n\tplay() {\n\t\tif (this.player) {\n\t\t\tif (this.retryPlayTimeout) {\n\t\t\t\tthis.retryPlayTimeout = clearTimeout(this.retryPlayTimeout);\n\t\t\t}\n\n\t\t\tthis.handleRetry();\n\t\t\tthis.player.play().catch((error) => {\n\t\t\t\tif (!this.video) return;\n\t\t\t\tthis.video.pause();\n\t\t\t\tthis.handleRetry();\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Pause video playback.\n\t */\n\tpause() {\n\t\tif (this.player) {\n\t\t\tthis.player.pause();\n\t\t}\n\t}\n\n\t/**\n\t * Stop video playback and reset the player.\n\t */\n\tstop() {\n\t\tif (this.player) {\n\t\t\tthis.player.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Restart connection to the stream.\n\t */\n\trestart() {\n\t\tconsole.warn(\"Restarting player...\");\n\t\tconst elementId = this.elementId;\n\t\tconst streamUrl = this.streamUrl;\n\t\tconst options = this.options;\n\t\tconst config = this.config;\n\t\tthis.destroy();\n\t\tvpMsePlayer(elementId).setup(streamUrl, options, config);\n\t}\n\n\t/**\n\t * Destroy the WebSocket worker used by the mse-player.\n\t * @private\n\t */\n\tdestroyWsWorker() {\n\t\tif (this.player) {\n\t\t\tthis.stop();\n\t\t\tif (this.player.ws) this.player.ws.destroy();\n\t\t}\n\t}\n\n\thandleRetry() {\n\t\tif (this.retryPlayTimeout) {\n\t\t\tthis.retryPlayTimeout = clearTimeout(this.retryPlayTimeout);\n\t\t}\n\n\t\tthis.retryPlayTimeout = setTimeout(() => {\n\t\t\tthis.restart();\n\t\t}, RETRYPLAY_TIMEOUT);\n\t}\n\n\t/**\n\t * Destroy the player and clean up resources.\n\t */\n\tdestroy() {\n\t\tthis.removeEventListeners();\n\t\tthis.clearResiduals();\n\t\tthis.videoContainer.classList.remove(\"vp-mse-player-container\");\n\t\tthis.videoContainer.innerHTML = \"\";\n\t\tthis.video.src = \"\";\n\t\tthis.video = null;\n\t\tthis.channelStatus = null;\n\t\tthis.status = null;\n\t\tif (this.player) {\n\t\t\tthis.destroyWsWorker();\n\t\t\tthis.player = null;\n\t\t}\n\t\tvpMsePlayer.destroy(this.elementId);\n\t}\n}\n\nwindow.vpMsePlayer = vpMsePlayer;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (vpMsePlayer);\n\n\n//# sourceURL=webpack://vp-mse-player/./src/index.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The require scope
/******/ var __webpack_require__ = {};
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = {};
/******/ __webpack_modules__["./src/index.js"](0, __webpack_exports__, __webpack_require__);
/******/ var __webpack_exports__default = __webpack_exports__["default"];
/******/ export { __webpack_exports__default as default };
/******/ 
